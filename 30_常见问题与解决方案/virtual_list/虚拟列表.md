# 无限滚动

- 下拉到底，继续加载数据并进行拼接
- 数据量太大，需要用虚拟列表展示

## 虚拟列表

> 虚拟列表的实现，就是在首屏加载的时候，只展示可视区域内的列表项，当滚动发生的时候，通过计算获取可视区域内的展示项，将非可视区域内的列表项删除

- 计算 可视区域 数据起始索引 startIndex
- 计算 可视区域 数据结束索引 endIndex
- 计算 可视区域 数据量并渲染到页面中
- 计算 数据偏移量 startIndex 对应数据在整个列表中的偏移量 startOffset

### 滚动

> 由于只是对可视区域进行数据渲染，我们需要
> a. 一个容器 仅为可视区域大小
> b. 一个占位元素 用来撑开高度保证列表能滚动
> c. 一个展示容器 用来在可视区域内渲染展示列表

- virtual_list_wrap 容器 仅为可视区域大小
- virtual_list_phantom 占位元素 撑开内容使可视区域内能滚动
- virtual_list_content 展示容器 可视区域内展示列表的容器

### 监听滚动

> 监听 virtual_list_content 的滚动事件 获取滚动位置 scrollTop

- 获取 可视区域的高度 visibleHeight
- 获取 单行元素的高度 itemSize
- 获取 总的列表数据（含不显示） listData
- 获取 当前滚动位置 scrollTop

### 得出最终数据

> 列表（含不显示）总高
`listHeight = listData * itemSize`

> 可显示的列表项 数量
`visibleCount = Math.ceil(visibleHeight / itemSize)`

> 展示数据的起始索引
`startIndex = Math.floor(scrollTop / itemSize)`

> 展示数据的结束索引
`endIndex = startIndex + visibleCount - 1`

> 展示的数据
`visibleData = listData.slice(startIndex, endIndex + 1)`

> 偏移渲染区域 偏移量
`startOffset = scrollTop - (scrollTop % itemSize)`

### 无限滚动

> 当滚动触底，加载新的数据拼接至原来的数据 listData 上


